////
Copyright 2020 Peter Dimov
Distributed under the Boost Software License, Version 1.0.
https://www.boost.org/LICENSE_1_0.txt
////

[#examples]
# Usage Examples
:idprefix: example_

[#printing_enums_ct]
## Printing Enumerators with a Compile Time Loop

A simple example that just iterates over the enumerator
descriptors using `mp11::mp_for_each` and prints them.

[source]
----
include::../../example/printing_enums_ct.cpp[lines=5..-1]
----

## Printing Enumerators with a Run Time Loop

This is similar to the previous example, but it first builds a
`std::array` with the values, and then iterates over it using
an ordinary `for` loop, instead of `mp_for_each`.

[source]
----
include::../../example/printing_enums_rt.cpp[lines=5..-1]
----

## enum_to_string

This example shows a function that, given an enumerator
value, returns its name.

Providing `enum_to_string` in a library is made difficult
by the fact that the desired behavior when the passed value
does not correspond to a named enumerator varies depending
on the specific use case. But, since defining the function
is trivial when `describe_enumerators` is available, every
user can easily have his own.

This specific example elects to return `"(unknown)"` when
the enum value doesn't have a name.

[source]
----
include::../../example/enum_to_string.cpp[lines=5..-1]
----

## string_to_enum

The opposite of the previous example; returns an enumerator
value when given the enumerator name. The same problem exists
here with respect to the error handling strategy when the string
passed does not correspond to any enumerator name. This example
throws an exception.

[source]
----
include::../../example/string_to_enum.cpp[lines=5..-1]
----

## Defining a Universal Print Function

This example defines a universal `operator<<` that works on
any class or struct type that has been described with
`BOOST_DESCRIBE_STRUCT` or `BOOST_DESCRIBE_CLASS`.

It first prints the base classes, recursively, then prints
all the members.

(A C cast is used to access private base classes. This is
not as bad as it first appears, because we're only inspecting
the base class by printing its members, and doing so should not
change its state and hence cannot violate its invariant.)

[source]
----
include::../../example/print_function.cpp[lines=5..-1]
----

## Defining a Universal Conversion to JSON

This example defines a universal `tag_invoke` overload that
automatically converts an annotated struct to JSON by iterating
over the described public members and adding them to the return
`json::object`.

The overload is defined in namespace `app` in order to apply
to all annotated classes also defined in `app`.

The presence of private members is taken as an indication that
a universal conversion is not suitable, so the overload is
disabled in this case using `std::enable_if_t`.

[source]
----
include::../../example/to_json.cpp[lines=5..-1]
----

## Defining a Universal Conversion from JSON

Like the previous example, but in the other direction.

[source]
----
include::../../example/from_json.cpp[lines=5..-1]
----

## Automatic Serialization

This example defines a universal `serialize` function that
automatically adds Boost.Serialization support to annotated
classes.

[source]
----
include::../../example/serialization.cpp[lines=5..-1]
----

